#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use lib ($ENV{RLWRAP_FILTERDIR} or '.');
use RlwrapFilter;

my $filter = RlwrapFilter->new();
my $name = $filter->name();

my $usage = <<EOF;
Usage:
  rlwrap -z '$name [OPT]...' <command>
Handy aliases, completion, and auto-repetition for jdb.
Options:
  --breakpoints-file F  File containing breakpoints for completion;
                        generate with list-java-breakpoints.
EOF

my($breakpoints_file);
GetOptions(
    'breakpoints-file=s' => \$breakpoints_file,
) or die("$usage\n");

my(@breakpoints);
if (defined($breakpoints_file)) {
    open IN, '<', $breakpoints_file
        or die("Problem opening breakpoints-file $breakpoints_file: $!\n");
    while (<IN>) {
        chomp;
        push(@breakpoints, $_);
    }
}

my($raw_line, $repeat_expanded_line, $pager_fd);

$filter->input_handler(sub {
    my($line) = @_;
    $raw_line = $line;
    my($expanded_line) = expand($line);
    $repeat_expanded_line = $expanded_line
        if $expanded_line =~ /^\s*(?:next|step|step up|cont)\s*$/;
    if ($expanded_line =~ /^\s*help/) {
        open($pager_fd, '|-', 'less') or die $!;
    }
    $expanded_line;
});
$filter->echo_handler(sub { $raw_line });

$filter->completion_handler(sub {
    my($l, $prefix, @completions) = @_;
    if ($l =~ /^\s*(?:b|stop at|stop in)\s+(\S+)/) {
        # try to check that they are completing in the break arg
        if ($prefix eq $1) {
            push(@completions, breakpoint_completions(\@breakpoints, $prefix));
        }
    }
    @completions;
});

sub breakpoint_completions {
    my($breakpoints, $prefix) = @_;
    my($min) = breakpoints_search($breakpoints, sub {
        my($breakpoint) = @_;
        return 0 if $breakpoint eq $prefix;
        return 2 if $breakpoint lt $prefix;
        return -1 if substr($breakpoint, 0, length($prefix)) eq $prefix;
        return -2 if $breakpoint gt $prefix;
    });
    return if !defined($min);
    my($max) = breakpoints_search($breakpoints, sub {
        my($breakpoint) = @_;
        return 0 if $breakpoint eq $prefix;
        return 2 if $breakpoint lt $prefix;
        return 1 if substr($breakpoint, 0, length($prefix)) eq $prefix;
        return -2 if $breakpoint gt $prefix;
    });
    @$breakpoints[$min..$max];
}

sub breakpoints_search {
    my($breakpoints, $cmp) = @_;
    my $min = 0;
    my $max = $#$breakpoints;
    my $mid = int(($min + $max) / 2);
    while ($min <= $max) {
        my $r = $cmp->($breakpoints->[$mid]);
        if      ($r == -2) {  # definitely go lower
            $max = $mid - 1;
            $mid = int(($min + $max) / 2);
        } elsif ($r == -1) {  # maybe go lower
            return $min if $min == $max;
            $max = $mid;
            $mid = int(($min + $max) / 2);
        } elsif ($r == 0) {
            return $mid;
        } elsif ($r == 1) {   # maybe go higher
            return $min if $min == $max;
            $min = $mid;
            $mid = int(($min + $max + 1) / 2);
        } elsif ($r == 2) {   # definitely go higher
            $min = $mid + 1;
            $mid = int(($min + $max + 1) / 2);
        }
    }
    undef;
}

sub common_prefix {
    my($a, $b) = @_;
    my $i = 0;
    while (1) {
        return substr($a, 0, $i)
            if $i>=length($a) || $i>=length($b) ||
                substr($a, $i, 1) ne substr($b, $i, 1);
        $i++;
    }
}

sub uniq {
    my(@r, $last);
    foreach (@_) {
        next if defined($last) && $_ eq $last;
        push(@r, $_);
        $last = $_;
    }
    @r
}

sub expand {
    my($line) = @_;
    if ($line =~ /^\s*$/) {
        $repeat_expanded_line // '';
    } else {
        $line =~ s/^\s*(\w+)(.*)/expand_alias($1,$2) . $2/e;
        $line;
    }
}

my(%aliases) = (
    h  => 'help',
    B  => 'clear',
    r  => 'run',
    n  => 'next',
    s  => 'step',
    r  => 'step up',
    c  => 'cont',
    p  => 'print',
    d  => 'dump',
    bt => 'where',
    l  => 'list',
    q  => 'quit',
);
sub expand_alias {
    my($s, $r) = @_;
    if ($s eq 'b') {
        $r =~ /^\s*$/
            ? 'clear' :
        $r =~ /:/
            ? 'stop at'
            : 'stop in';
    } else {
        $aliases{$s} // $s;
    }
}

# this sends us the prompt too, unless in patient mode
$filter->output_handler(sub {
    my($s) = @_;
    if (defined($pager_fd)) {
        print $pager_fd $s;
        ''
    } else {
        $s;
    }
});
$filter->prompt_handler(sub {
    my($prompt) = @_;
    if (defined($pager_fd)) {
        close($pager_fd) or die $!;
        $pager_fd = undef;
    }
    $prompt;
});

$filter->help_text($usage);

$filter->run();
