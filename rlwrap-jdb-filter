#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;

use lib ($ENV{RLWRAP_FILTERDIR} or '.');
use RlwrapFilter;

my $filter = RlwrapFilter->new();
my $name = $filter->name();

my $usage = <<EOF;
Usage:
  rlwrap -z '$name [OPT]...' <command>
Handy aliases, completion, and auto-repetition for jdb.
Options:
  --breakpoints-file F  File containing breakpoints for completion;
                        generate with list-java-breakpoints.
  --main-class C        The main class to debug.  This is not essential, and
                        rlwrap-jdb can often figure it out itself.
EOF

$filter->help_text($usage);

my($breakpoints_file, $main_class);
GetOptions(
    'breakpoints-file=s' => \$breakpoints_file,
    'main-class=s'       => \$main_class,
) or die("$usage\n");

my(@breakpoints);
if (defined($breakpoints_file)) {
    open IN, '<', $breakpoints_file
        or die("Problem opening breakpoints-file $breakpoints_file: $!\n");
    while (<IN>) {
        chomp;
        push(@breakpoints, $_);
    }
}

my($raw_line, $repeat_expanded_line, $pager_fd);
my $current_class = $main_class;

$filter->input_handler(sub {
    my($line) = @_;
    $raw_line = $line;
    my($expanded_line) = expand($line);
    $repeat_expanded_line = $expanded_line
        if $expanded_line =~ /^\s*(?:next|step|step up|cont)\s*$/;
    if ($expanded_line =~ /^\s*(?:help|\?)\s*/) {
        open($pager_fd, '|-', 'less') or die $!;
    }
    $expanded_line;
});

$filter->echo_handler(sub { $raw_line });

# this sends us the prompt too, unless in patient mode
$filter->output_handler(sub {
    my($s) = @_;
    if (defined($pager_fd)) {
        print $pager_fd $s;
        ''
    } else {
        # parse the current class
        if ($s =~ /: "thread=.*?", ([a-zA-Z.\$]+)\.[a-zA-Z]+\(\), line=/) {
            $current_class = $1;
        }
        $s;
    }
});

$filter->prompt_handler(sub {
    my($prompt) = @_;
    if (defined($pager_fd)) {
        close($pager_fd) or die $!;
        $pager_fd = undef;
    }
    $prompt;
});

$filter->completion_handler(sub {
    my($l, $prefix, @completions) = @_;
    # try to check that they are completing in the break arg
    if ($l =~ /^\s*(?:b|stop at|stop in)\s+(\S*)/) {
        my $break_arg = $1;
        if ($prefix eq $break_arg) {
            push(@completions,
                $prefix eq ''
                    ? defined($current_class)
                        ? breakpoint_completions(\@breakpoints, $current_class)
                        : ()
                    : breakpoint_completions(\@breakpoints, $prefix));
        }
    }
    @completions;
});

$filter->run();
exit;

sub breakpoint_completions {
    my($breakpoints, $prefix) = @_;
    my($min) = breakpoints_search($breakpoints, sub {
        my($breakpoint) = @_;
        return 0 if $breakpoint eq $prefix;
        return 2 if $breakpoint lt $prefix;
        return -1 if substr($breakpoint, 0, length($prefix)) eq $prefix;
        return -2 if $breakpoint gt $prefix;
    });
    return if !defined($min);
    my($max) = breakpoints_search($breakpoints, sub {
        my($breakpoint) = @_;
        return 0 if $breakpoint eq $prefix;
        return 2 if $breakpoint lt $prefix;
        return 1 if substr($breakpoint, 0, length($prefix)) eq $prefix;
        return -2 if $breakpoint gt $prefix;
    });
    @$breakpoints[$min..$max];
}

sub breakpoints_search {
    my($breakpoints, $cmp) = @_;
    my $min = 0;
    my $max = $#$breakpoints;
    my $mid = int(($min + $max) / 2);
    while ($min <= $max) {
        my $r = $cmp->($breakpoints->[$mid]);
        if      ($r == -2) {  # definitely go lower
            $max = $mid - 1;
            $mid = int(($min + $max) / 2);
        } elsif ($r == -1) {  # maybe go lower
            return $min if $min == $max;
            $max = $mid;
            $mid = int(($min + $max) / 2);
        } elsif ($r == 0) {
            return $mid;
        } elsif ($r == 1) {   # maybe go higher
            return $min if $min == $max;
            $min = $mid;
            $mid = int(($min + $max + 1) / 2);
        } elsif ($r == 2) {   # definitely go higher
            $min = $mid + 1;
            $mid = int(($min + $max + 1) / 2);
        }
    }
    undef;
}

sub common_prefix {
    my($a, $b) = @_;
    my $i = 0;
    while (1) {
        return substr($a, 0, $i)
            if $i>=length($a) || $i>=length($b) ||
                substr($a, $i, 1) ne substr($b, $i, 1);
        $i++;
    }
}

sub uniq {
    my(@r, $last);
    foreach (@_) {
        next if defined($last) && $_ eq $last;
        push(@r, $_);
        $last = $_;
    }
    @r
}

sub expand {
    my($line) = @_;
    if ($line =~ /^\s*$/) {
        $repeat_expanded_line // '';
    } else {
        $line =~ s/^\s*(\w+)(.*)/expand_alias($1,$2) . $2/e;
        $line;
    }
}

my(%aliases);
BEGIN {
    %aliases = (
        h  => 'help',
        B  => 'clear',
        r  => 'run',
        n  => 'next',
        s  => 'step',
        r  => 'step up',
        c  => 'cont',
        p  => 'print',
        d  => 'dump',
        bt => 'where',
        l  => 'list',
        q  => 'quit',
    );
}
sub expand_alias {
    my($s, $r) = @_;
    if ($s eq 'b') {
        $r =~ /^\s*$/
            ? 'clear' :
        $r =~ /:/
            ? 'stop at'
            : 'stop in';
    } else {
        $aliases{$s} // $s;
    }
}
